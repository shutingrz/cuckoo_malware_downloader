import os, urllib.request, urllib.error, socket, requests, threading, random

class TempBufferedReader():
  def __init__(self, filepath, filename):
    self.filepath = filepath
    self.name = filename

  def read(self):
    with open(self.filepath, "rb") as fileobj:
      return fileobj.read()


class Downloader(threading.Thread):

  POST_PATH = "tasks/create/submit"
  socket.setdefaulttimeout(10)
    
  def __init__(self, url=None, ua=None, filename=None, taskInfo=None, cuckoo_host=None):
    super(Downloader, self).__init__()
    self.url = url
    self.ua = ua
    self.filename = filename
    self.taskInfo = taskInfo
    self.post_url = cuckoo_host + self.POST_PATH

  def run(self):

    url = self.url
    ua = self.ua
    filename = self.filename

    self.taskInfo["state"] = "STARTED"
    self.taskInfo["isStarted"] = "1"


    result = None
    #fetch malware.
    self.taskInfo["state"] = "FETCH"
    tmpFilepath, result = self._fetch(url, ua, filename)
    
    if result["code"] > 0:
      self.taskInfo["state"] = "STOP"
      self.taskInfo["ErrorPoint"] = "fetch"
      self.taskInfo["ErrorMessage"] = result["reason"]
      return None
    else:
      self.taskInfo["state"] = "SUBMIT"
      self.taskInfo["isFetched"] = "1"
      self.taskInfo["isInstalled"] = "1"


    result = None
    #submit cuckoo api
    submit_id, result = self._submit(self.post_url, tmpFilepath, filename)

    #filenalize
    try:
      os.remove(tmpFilepath)
    except Exception as exc:
      self.taskInfo["WarningMessage"].append("テンポラリファイルの削除に失敗しました。開発者にお知らせください。 (%s)" % str(exc))
    
    if result["code"] > 0:
      self.taskInfo["state"] = "STOP"
      self.taskInfo["ErrorPoint"] = "fetch"
      self.taskInfo["ErrorMessage"] = result["reason"]
      return None
    else:
      self.taskInfo["state"] = "FINISH"
      self.taskInfo["isSubmitted"] = "1"
      self.taskInfo["submit_id"] = submit_id
      return 1
      
  def fetchReport(self, count, block_size, total_size):
    percent = int(count * block_size * 100 / total_size)
    self.taskInfo["fetchPercent"] = str(percent)


  def _fetch(self, url, ua, filename):
    opener = urllib.request.build_opener()
    result = {}

    if ua is not None:
      opener.addheaders = [('User-Agent', ua)]

    try:
      urllib.request.install_opener(opener)
      tmpFilepath, headers = urllib.request.urlretrieve(url, reporthook=self.fetchReport)
    except urllib.error.URLError as exc:
      result["code"] = 10
      result["reason"] = str(exc)
      return None, result
    except urllib.error.HTTPError as exc:
      result["code"] = 20
      result["reason"] = str(exc)
      os.remove(tmpFilepath)
      return None, result
    except Exception as exc:
      result["code"] = 30
      result["reason"] = str(exc)
      os.remove(tmpFilepath)
      return None, result

    result["code"] = 0
    return tmpFilepath, result




  def _submit(self, post_url, tmpFilepath, filename):
    result = {}
    tmpBuf = TempBufferedReader(tmpFilepath, filename)
    response = requests.post(post_url, files=[
        ("files", tmpBuf),
    ], data={'timeout': '30'})

    try:
      submit_id = response.json()["submit_id"]
    except Exception as exc:
      result["code"] = 40
      result["reason"] = str(exc)
      return None, result

    result["code"] = 0
    return submit_id, result
